//go:build unit

// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package actor_mocks

import (
	"context"

	"github.com/italypaleale/actors/actor"
	mock "github.com/stretchr/testify/mock"
)

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient[T any](t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient[T] {
	mock := &MockClient[T]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockClient is an autogenerated mock type for the Client type
type MockClient[T any] struct {
	mock.Mock
}

type MockClient_Expecter[T any] struct {
	mock *mock.Mock
}

func (_m *MockClient[T]) EXPECT() *MockClient_Expecter[T] {
	return &MockClient_Expecter[T]{mock: &_m.Mock}
}

// DeleteAlarm provides a mock function for the type MockClient
func (_mock *MockClient[T]) DeleteAlarm(ctx context.Context, alarmName string) error {
	ret := _mock.Called(ctx, alarmName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAlarm")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, alarmName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_DeleteAlarm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAlarm'
type MockClient_DeleteAlarm_Call[T any] struct {
	*mock.Call
}

// DeleteAlarm is a helper method to define mock.On call
//   - ctx context.Context
//   - alarmName string
func (_e *MockClient_Expecter[T]) DeleteAlarm(ctx interface{}, alarmName interface{}) *MockClient_DeleteAlarm_Call[T] {
	return &MockClient_DeleteAlarm_Call[T]{Call: _e.mock.On("DeleteAlarm", ctx, alarmName)}
}

func (_c *MockClient_DeleteAlarm_Call[T]) Run(run func(ctx context.Context, alarmName string)) *MockClient_DeleteAlarm_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockClient_DeleteAlarm_Call[T]) Return(err error) *MockClient_DeleteAlarm_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_DeleteAlarm_Call[T]) RunAndReturn(run func(ctx context.Context, alarmName string) error) *MockClient_DeleteAlarm_Call[T] {
	_c.Call.Return(run)
	return _c
}

// DeleteState provides a mock function for the type MockClient
func (_mock *MockClient[T]) DeleteState(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteState")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_DeleteState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteState'
type MockClient_DeleteState_Call[T any] struct {
	*mock.Call
}

// DeleteState is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockClient_Expecter[T]) DeleteState(ctx interface{}) *MockClient_DeleteState_Call[T] {
	return &MockClient_DeleteState_Call[T]{Call: _e.mock.On("DeleteState", ctx)}
}

func (_c *MockClient_DeleteState_Call[T]) Run(run func(ctx context.Context)) *MockClient_DeleteState_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockClient_DeleteState_Call[T]) Return(err error) *MockClient_DeleteState_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_DeleteState_Call[T]) RunAndReturn(run func(ctx context.Context) error) *MockClient_DeleteState_Call[T] {
	_c.Call.Return(run)
	return _c
}

// GetState provides a mock function for the type MockClient
func (_mock *MockClient[T]) GetState(ctx context.Context) (T, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetState")
	}

	var r0 T
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (T, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) T); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(T)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetState'
type MockClient_GetState_Call[T any] struct {
	*mock.Call
}

// GetState is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockClient_Expecter[T]) GetState(ctx interface{}) *MockClient_GetState_Call[T] {
	return &MockClient_GetState_Call[T]{Call: _e.mock.On("GetState", ctx)}
}

func (_c *MockClient_GetState_Call[T]) Run(run func(ctx context.Context)) *MockClient_GetState_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockClient_GetState_Call[T]) Return(state T, err error) *MockClient_GetState_Call[T] {
	_c.Call.Return(state, err)
	return _c
}

func (_c *MockClient_GetState_Call[T]) RunAndReturn(run func(ctx context.Context) (T, error)) *MockClient_GetState_Call[T] {
	_c.Call.Return(run)
	return _c
}

// SetAlarm provides a mock function for the type MockClient
func (_mock *MockClient[T]) SetAlarm(ctx context.Context, alarmName string, properties actor.AlarmProperties) error {
	ret := _mock.Called(ctx, alarmName, properties)

	if len(ret) == 0 {
		panic("no return value specified for SetAlarm")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, actor.AlarmProperties) error); ok {
		r0 = returnFunc(ctx, alarmName, properties)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_SetAlarm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAlarm'
type MockClient_SetAlarm_Call[T any] struct {
	*mock.Call
}

// SetAlarm is a helper method to define mock.On call
//   - ctx context.Context
//   - alarmName string
//   - properties actor.AlarmProperties
func (_e *MockClient_Expecter[T]) SetAlarm(ctx interface{}, alarmName interface{}, properties interface{}) *MockClient_SetAlarm_Call[T] {
	return &MockClient_SetAlarm_Call[T]{Call: _e.mock.On("SetAlarm", ctx, alarmName, properties)}
}

func (_c *MockClient_SetAlarm_Call[T]) Run(run func(ctx context.Context, alarmName string, properties actor.AlarmProperties)) *MockClient_SetAlarm_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 actor.AlarmProperties
		if args[2] != nil {
			arg2 = args[2].(actor.AlarmProperties)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockClient_SetAlarm_Call[T]) Return(err error) *MockClient_SetAlarm_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_SetAlarm_Call[T]) RunAndReturn(run func(ctx context.Context, alarmName string, properties actor.AlarmProperties) error) *MockClient_SetAlarm_Call[T] {
	_c.Call.Return(run)
	return _c
}

// SetState provides a mock function for the type MockClient
func (_mock *MockClient[T]) SetState(ctx context.Context, state T) error {
	ret := _mock.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for SetState")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, T) error); ok {
		r0 = returnFunc(ctx, state)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_SetState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetState'
type MockClient_SetState_Call[T any] struct {
	*mock.Call
}

// SetState is a helper method to define mock.On call
//   - ctx context.Context
//   - state T
func (_e *MockClient_Expecter[T]) SetState(ctx interface{}, state interface{}) *MockClient_SetState_Call[T] {
	return &MockClient_SetState_Call[T]{Call: _e.mock.On("SetState", ctx, state)}
}

func (_c *MockClient_SetState_Call[T]) Run(run func(ctx context.Context, state T)) *MockClient_SetState_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 T
		if args[1] != nil {
			arg1 = args[1].(T)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockClient_SetState_Call[T]) Return(err error) *MockClient_SetState_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_SetState_Call[T]) RunAndReturn(run func(ctx context.Context, state T) error) *MockClient_SetState_Call[T] {
	_c.Call.Return(run)
	return _c
}
